{% extends "base.html" %}
{% load static %}

{% block page_styles %}
<style>
    .csv-cell {
        width: fit-content !important;
        display: inline-block;
        min-width: 90px;
        padding: 2px 6px;
    }
    .csv-preview-table input {
        width: auto;
    }
</style>
{% endblock %}

{% block content %}
<div class="d-flex align-items-left align-items-md-center flex-column flex-md-row pt-2 pb-4">
    <div>
        <h3 class="fw-bold mb-3">Upload Bulk Users</h3>
    </div>
    <div class="ms-md-auto py-2 py-md-0">
        <a href="{% url 'accounts:add_user_url' %}" class="btn btn-primary btn-round ms-auto" id="openAddUserPage">Add
            User</a>
    </div>
</div>
<div class="row">
    <div class="col-md-12">
        <div class="card">
            <div class="card-body">
                <input id="csvFileInput" class="form-control" type="file" accept=".csv" />
                <div id="csvPreviewContainer" class="table-responsive mt-5"></div>
                <!-- Buttons appear dynamically; but you can reserve a spot -->
                <div id="csvPreviewActions"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block page_scripts %}
<script>
/* ---------- Helpers (CSV parse + UI) ---------- */

function parseCSV(text) {
    const rows = [];
    let cur = '', row = [], inQuotes = false;
    for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];
        if (ch === '"') {
            if (inQuotes && next === '"') { cur += '"'; i++; continue; }
            inQuotes = !inQuotes;
            continue;
        }
        if (!inQuotes && ch === ',') { row.push(cur); cur = ''; continue; }
        if (!inQuotes && (ch === '\n' || ch === '\r')) {
            if (ch === '\r' && text[i + 1] === '\n') { i++; }
            row.push(cur); rows.push(row); row = []; cur = ''; continue;
        }
        cur += ch;
    }
    if (cur !== '' || row.length) { row.push(cur); rows.push(row); }
    return rows;
}

function arrayToObjects(rows) {
    if (!rows || rows.length === 0) return { headers: [], data: [], ok: false, message: 'CSV empty' };
    const headers = rows[0].map(h => h.trim());
    const data = rows.slice(1).map(r => {
        const obj = {};
        for (let i = 0; i < headers.length; i++) obj[headers[i]] = (r[i] ?? '').trim();
        return obj;
    });
    return { headers, data, ok: true };
}

// create a simple text input element for preview
function makeTextInput(value, fieldName, rowIndex) {
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'form-control csv-cell';
    input.value = value ?? '';
    input.dataset.field = fieldName;
    input.dataset.rowIndex = String(rowIndex);

    input.addEventListener('input', () => {
        // ensures only THIS field clears error
        clearFieldError(input);

        // UPDATE ROW OBJECT without render
        const r = parseInt(input.dataset.rowIndex);
        const f = input.dataset.field;

        if (currentRows && currentRows[r]) {
            currentRows[r][f] = input.value.trim(); // update live data
        }

        // update error state only for this field
        if (currentErrors && currentErrors[r] && currentErrors[r][f]) {
            delete currentErrors[r][f];
            currentErrors[r]._rowErrorCount = Object.keys(currentErrors[r])
                .filter(k => k !== "_rowErrorCount").length;
        }

        // DO NOT re-render here â†’ fixes scroll + ghost errors
    });

    return input;
}

function clearFieldError(input) {
    const parent = input.parentElement;
    const err = parent.querySelector('.csv-error');
    if (err) err.remove();
    input.classList.remove('is-invalid');
}

function showFieldError(input, msg) {
    clearFieldError(input);
    input.classList.add('is-invalid');
    const small = document.createElement('div');
    small.className = 'form-text text-danger csv-error';
    small.innerText = msg;
    input.parentElement.appendChild(small);
}

function renderPreview(container, rows, errors, schema) {
    container.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'table table-sm table-bordered csv-preview-table';
    const thead = document.createElement('thead');
    const trHead = document.createElement('tr');
    for (const col of schema) {
        const th = document.createElement('th'); th.innerText = col.label || col.name;
        trHead.appendChild(th);
    }
    const thActions = document.createElement('th'); thActions.innerText = 'Actions';
    trHead.appendChild(thActions);
    thead.appendChild(trHead);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    rows.forEach((rowObj, rowIndex) => {
        const tr = document.createElement('tr');
        for (const col of schema) {
            const td = document.createElement('td');
            const input = makeTextInput(rowObj[col.name], col.name, rowIndex);
            td.appendChild(input);

            // server-side style errors (if present)
            const ferr = errors?.[rowIndex]?.[col.name];
            if (ferr) showFieldError(input, ferr);
            tr.appendChild(td);
        }
        // actions column (delete)
        const tdAct = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.className = 'btn btn-sm btn-outline-danger';
        delBtn.type = 'button';
        delBtn.innerText = 'Delete';
        delBtn.dataset.rowIndex=rowIndex
        tdAct.appendChild(delBtn)
        tr.appendChild(tdAct);
        tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    container.appendChild(table);
}

function collectEditedRows(container, schema) {
    const rows = [];
    const tbodyRows = container.querySelectorAll('tbody tr');
    tbodyRows.forEach(tr => {
        const obj = {};
        schema.forEach((col) => {
            const input = tr.querySelector(`input[data-field="${col.name}"]`);
            obj[col.name] = input ? input.value.trim() : '';
        });
        rows.push(obj);
    });
    return rows;
}

function dispatchPreviewChange() {
    document.dispatchEvent(new CustomEvent('csvPreviewChanged'));
}

function getCSRF() {
    const name = 'csrftoken';
    const cookies = document.cookie.split(';').map(c => c.trim());
    for (const c of cookies) {
        if (c.startsWith(name + '=')) return decodeURIComponent(c.split('=')[1]);
    }
    return '';
}

function attachDeleteEvents() {
    const deleteButtons = previewContainer.querySelectorAll("button.btn-outline-danger");
    deleteButtons.forEach(btn=>{
        btn.addEventListener("click",()=>{
            const index = parseInt(btn.dataset.rowIndex)

            currentRows.splice(index,1)
            currentErrors.splice(index,1)

            btn.closest("tr").remove()   // no re-render => no scroll reset

            // re-index rowIndex attributes on inputs/buttons
            previewContainer.querySelectorAll("tbody tr").forEach((rowEl,newIdx)=>{
                rowEl.querySelectorAll("input").forEach(inp=> inp.dataset.rowIndex=newIdx );
                rowEl.querySelector("button.btn-outline-danger").dataset.rowIndex=newIdx
            })
        })
    })
}

/* ---------- CSV page initializer (validate -> create) ---------- */
function initCsvUploader({ fileInputId, previewContainerId, schema, validateUrl, uploadUrl, exactHeaderOrder = true }) {
    const fileInput = document.getElementById(fileInputId);
    const previewContainer = document.getElementById(previewContainerId);
    const actionsContainer = document.getElementById('csvPreviewActions');

    let currentRows = [];
    let currentErrors = [];

    function clearActions() { actionsContainer.innerHTML = ''; }

    function renderActionsState(state) {
        // state: { validated: boolean, totalErrors: number }
        clearActions();
        const info = document.createElement('div');
        info.className = 'mb-2';
        info.innerText = `${currentRows.length} row(s). ${state.totalErrors} error(s)`;
        actionsContainer.appendChild(info);

        // Validate button
        const validateBtn = document.createElement('button');
        validateBtn.className = 'btn btn-sm btn-outline-primary me-2';
        validateBtn.type = 'button';
        validateBtn.innerText = 'Validate (server)';
        validateBtn.addEventListener('click', async () => {
            // collect current table state
            currentRows = collectEditedRows(previewContainer, schema);
            // call backend validate endpoint
            validateBtn.disabled = true;
            validateBtn.innerText = 'Validating...';
            try {
                const res = await fetch(validateUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRF()
                    },
                    body: JSON.stringify({ rows: currentRows })
                });
                const data = await res.json();
                validateBtn.disabled = false;
                validateBtn.innerText = 'Validate (server)';
                if (data.success === false && data.rowErrors) {
                    currentErrors = data.rowErrors;
                    renderPreview(previewContainer, currentRows, currentErrors, schema);
                    renderActionsState({ validated: true, totalErrors: data.rowErrors.reduce((s,e)=>s+(e._rowErrorCount||0),0) });
                    // focus first invalid field
                    const firstInvalid = previewContainer.querySelector('.is-invalid');
                    if (firstInvalid) firstInvalid.focus();
                    return;
                }
                // success: server says all ok
                currentErrors = [];
                renderPreview(previewContainer, currentRows, currentErrors, schema);
                renderActionsState({ validated: true, totalErrors: 0 });
                // enable create button by rendering it as well
                showCreateButton();
            } catch (err) {
                validateBtn.disabled = false;
                validateBtn.innerText = 'Validate (server)';
                showFlash('Validation network error: ' + err.message, true);
            }
        });
        actionsContainer.appendChild(validateBtn);

        // Cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn btn-sm btn-outline-secondary ms-2';
        cancelBtn.type = 'button';
        cancelBtn.innerText = 'Cancel';
        cancelBtn.addEventListener('click', () => {
            previewContainer.innerHTML = '';
            clearActions();
            fileInput.value = '';
            currentRows = [];
            currentErrors = [];
        });
        actionsContainer.appendChild(cancelBtn);
    }

    function showCreateButton() {
        const createBtn = document.createElement('button');
        createBtn.className = 'btn btn-sm btn-primary ms-3';
        createBtn.type = 'button';
        createBtn.innerText = 'Create';
        createBtn.addEventListener('click', async () => {
            // final call to create endpoint
            createBtn.disabled = true;
            createBtn.innerText = 'Creating...';
            try {
                const res = await fetch(uploadUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRF()
                    },
                    body: JSON.stringify({ rows: currentRows })
                });
                const data = await res.json();
                createBtn.disabled = false;
                createBtn.innerText = 'Create';
                if (res.status === 200 && data.success) {
                    // success: clear preview and show message
                    previewContainer.innerHTML = '';
                    clearActions();
                    fileInput.value = '';
                    showFlash(`Created ${data.created.length} users`);
                    currentRows = [];
                    currentErrors = [];
                    return;
                }
                // if server returns rowErrors (defensive), show them
                if (data.rowErrors) {
                    currentErrors = data.rowErrors;
                    renderPreview(previewContainer, currentRows, currentErrors, schema);
                    renderActionsState({ validated: true, totalErrors: data.rowErrors.reduce((s,e)=>s+(e._rowErrorCount||0),0) });
                    return;
                }
                // fallback error
                showFlash('Create failed: ' + (data.message || 'Unknown error'), true);
            } catch (err) {
                createBtn.disabled = false;
                createBtn.innerText = 'Create';
                showFlash('Network error: ' + err.message, true);
            }
        });

        actionsContainer.appendChild(createBtn);
    }

    function showFlash(msg, isError=false) {
        const f = document.createElement('div');
        f.className = isError ? 'text-danger' : 'text-success';
        f.innerText = msg;
        actionsContainer.appendChild(f);
        setTimeout(()=>f.remove(), 5000);
    }

    fileInput.addEventListener('change', (ev) => {
        const file = ev.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const text = e.target.result;
            const rows = parseCSV(text);
            if (!rows || rows.length < 2) {
                showFlash('CSV empty or contains only header', true);
                return;
            }
            const { headers, data } = arrayToObjects(rows);
            const expectedHeaders = schema.map(s => s.name);
            if (headers.length !== expectedHeaders.length || headers.some((h,i)=>h!==expectedHeaders[i])) {
                showFlash("CSV headers do not match required order", true);
                const msg = document.createElement('div');
                msg.className='form-text';
                msg.innerText="Expected: " + expectedHeaders.join(", ");
                actionsContainer.appendChild(msg);
                return;
            }
            currentRows = data;
            currentErrors = data.map(()=>({})); // start with empty errors so preview shows no inline errors initially
            renderPreview(previewContainer, currentRows, currentErrors, schema);
            renderActionsState({ validated: false, totalErrors: 0 });
        };
        reader.readAsText(file);
    });
}

/* ---------- initialization ---------- */
window.initCsvUploader = initCsvUploader;

document.addEventListener('DOMContentLoaded', function() {
    initCsvUploader({
        fileInputId: "csvFileInput",
        previewContainerId: "csvPreviewContainer",
        schema: [
            { name: 'first_name', label: 'First Name' },
            { name: 'last_name', label: 'Last Name' },
            { name: 'email', label: 'Email' },
            { name: 'phone', label: 'Phone' },
            { name: 'city', label: 'City' },
            { name: 'state', label: 'State' },
            { name: 'country', label: 'Country' },
            { name: 'company', label: 'Company Name' },
            { name: 'plan', label: 'Plan (Elite/Core/Digital)' }
        ],
        validateUrl: "{% url 'accounts:upload_bulk_clients_validate_url' %}",
        uploadUrl: "{% url 'accounts:upload_bulk_clients_page_url' %}",
        exactHeaderOrder: true
    });
});
</script>
{% endblock %}